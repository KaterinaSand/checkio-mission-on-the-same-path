<p style="text-align: justify;">
    You have to write a function that receive a tree &ndash; potentially large but finite &ndash;
    and a list of pairs of tree's nodes.
    For each pair, you must determine if the two nodes are on a same path in the tree
    (True if there are on the same path, False otherwise),
    then return a iterable/list of these booleans.
</p>

<p>
    Nodes are all integers or all strings.
    <br>
    <strong>Input:</strong> A tree: a tuple (node, list of sub-trees) ; and a list of pairs (tuples of two nodes).
    <br>
    <strong>Ouput:</strong> An iterable/list of booleans.
</p>

<p class="for_info_only">
<div style="text-align: center;">
    <img src="{{MEDIA}}basic-1.png" alt="basic #1" title="basic #1" style="max-height: 150px;">
    <img src="{{MEDIA}}basic-2.png" alt="basic #2" title="basic #2"
         style="max-height: 200px; margin-left: 15px; margin-right: 15px;">
    <img src="{{MEDIA}}basic-3.png" alt="basic #3" title="basic #3" style="max-height: 150px;">
</div>
<strong>Examples:</strong>
<pre class="brush: python">
on_same_path(
    ('Me', [('Daddy', [('Grandpa', []),
                       ('Grandma', [])]),
            ('Mom', [('Granny', []),
                     ('?', [])])]),
    [('Grandpa', 'Me'), ('Daddy', 'Granny')],
) == [True, False]

on_same_path(
    (1, [(2, [(4, []),
              (5, [(7, []),
                   (8, []),
                   (9, [])])]),
         (3, [(6, [])])]),
    [(1, 5), (2, 9), (2, 6)],
) == [True, True, False]

on_same_path(
    (0, [(1, [(2, []),
              (3, [])]),
         (4, [(5, []),
              (6, [])]),
         (7, [(8, []),
              (9, [])])]),
    [(4, 2), (0, 5), (2, 3), (9, 2), (6, 4), (7, 8), (8, 1)],
) == [False, True, False, False, True, True, False]
</pre>
</p>

<p>
    <strong>Preconditions:</strong>
    <ul>
        <li>The tree is finite and has less than 1000 nodes.</li>
        <li>len(pairs) &le; 32</li>
    </ul>
</p>
